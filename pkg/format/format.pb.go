// Code generated by protoc-gen-go. DO NOT EDIT.
// source: protos/format/format.proto

package format // import "github.com/empirefox/protoc-gen-dart-ext/pkg/format"

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import units "github.com/empirefox/protoc-gen-dart-ext/pkg/units"
import descriptor "github.com/golang/protobuf/protoc-gen-go/descriptor"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// Support field: `Datetime`, `Duration`, `[s,fixed]int64`(will mark it as
// time) or other `int` types. `int` values must be from utc.
//
// - `*Datetime[24H]` must set on `Datetime` or `int64` type.
// - `ofDay[24H]` must set on `Datetime` or `uint` types.
// - `duration` must set on `Duration` or any `int` types.
type TimeFormat_Builtin int32

const (
	// Formats the date using a medium-width format.
	//  Examples:
	// - US English: Wed, Sep 27
	// - Russian: ср, сент. 27
	TimeFormat_mediumDate TimeFormat_Builtin = 0
	// Formats day of week, month, day of month and year in a long-width format.
	// Examples:
	// - US English: Wednesday, September 27, 2017
	// - Russian: Среда, Сентябрь 27, 2017
	TimeFormat_fullData TimeFormat_Builtin = 1
	// 3:00pm or 15:00pm
	// default parse the int value as minute
	TimeFormat_ofDay TimeFormat_Builtin = 2
	// 15:00pm
	TimeFormat_ofDay24H          TimeFormat_Builtin = 3
	TimeFormat_mediumDatetime    TimeFormat_Builtin = 4
	TimeFormat_mediumDatetime24H TimeFormat_Builtin = 5
	TimeFormat_fullDatetime      TimeFormat_Builtin = 6
	TimeFormat_fullDatetime24H   TimeFormat_Builtin = 7
	TimeFormat_duration          TimeFormat_Builtin = 8
)

var TimeFormat_Builtin_name = map[int32]string{
	0: "mediumDate",
	1: "fullData",
	2: "ofDay",
	3: "ofDay24H",
	4: "mediumDatetime",
	5: "mediumDatetime24H",
	6: "fullDatetime",
	7: "fullDatetime24H",
	8: "duration",
}
var TimeFormat_Builtin_value = map[string]int32{
	"mediumDate":        0,
	"fullData":          1,
	"ofDay":             2,
	"ofDay24H":          3,
	"mediumDatetime":    4,
	"mediumDatetime24H": 5,
	"fullDatetime":      6,
	"fullDatetime24H":   7,
	"duration":          8,
}

func (x TimeFormat_Builtin) String() string {
	return proto.EnumName(TimeFormat_Builtin_name, int32(x))
}
func (TimeFormat_Builtin) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_format_e7436119009016db, []int{1, 0}
}

type TimeFormat_IntUnit int32

const (
	// invalid if field is of an int type
	TimeFormat_und TimeFormat_IntUnit = 0
	// Dart lost the nano part, eg. 1,100 becomes 1,000.
	TimeFormat_nanosecond  TimeFormat_IntUnit = 1
	TimeFormat_microsecond TimeFormat_IntUnit = 2
	TimeFormat_millisecond TimeFormat_IntUnit = 3
	TimeFormat_second      TimeFormat_IntUnit = 4
	TimeFormat_minute      TimeFormat_IntUnit = 5
	TimeFormat_hour        TimeFormat_IntUnit = 6
	// not on ofDay
	TimeFormat_day TimeFormat_IntUnit = 7
	// not on ofDay
	TimeFormat_week TimeFormat_IntUnit = 8
)

var TimeFormat_IntUnit_name = map[int32]string{
	0: "und",
	1: "nanosecond",
	2: "microsecond",
	3: "millisecond",
	4: "second",
	5: "minute",
	6: "hour",
	7: "day",
	8: "week",
}
var TimeFormat_IntUnit_value = map[string]int32{
	"und":         0,
	"nanosecond":  1,
	"microsecond": 2,
	"millisecond": 3,
	"second":      4,
	"minute":      5,
	"hour":        6,
	"day":         7,
	"week":        8,
}

func (x TimeFormat_IntUnit) String() string {
	return proto.EnumName(TimeFormat_IntUnit_name, int32(x))
}
func (TimeFormat_IntUnit) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_format_e7436119009016db, []int{1, 1}
}

type NumberFormat_Builtin int32

const (
	NumberFormat_decimal        NumberFormat_Builtin = 0
	NumberFormat_percent        NumberFormat_Builtin = 1
	NumberFormat_scientific     NumberFormat_Builtin = 2
	NumberFormat_currency       NumberFormat_Builtin = 3
	NumberFormat_currencySimple NumberFormat_Builtin = 4
)

var NumberFormat_Builtin_name = map[int32]string{
	0: "decimal",
	1: "percent",
	2: "scientific",
	3: "currency",
	4: "currencySimple",
}
var NumberFormat_Builtin_value = map[string]int32{
	"decimal":        0,
	"percent":        1,
	"scientific":     2,
	"currency":       3,
	"currencySimple": 4,
}

func (x NumberFormat_Builtin) String() string {
	return proto.EnumName(NumberFormat_Builtin_name, int32(x))
}
func (NumberFormat_Builtin) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_format_e7436119009016db, []int{3, 0}
}

type Format struct {
	// Types that are valid to be assigned to Type:
	//	*Format_Time
	//	*Format_Currency
	//	*Format_Number
	Type                 isFormat_Type `protobuf_oneof:"type"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *Format) Reset()         { *m = Format{} }
func (m *Format) String() string { return proto.CompactTextString(m) }
func (*Format) ProtoMessage()    {}
func (*Format) Descriptor() ([]byte, []int) {
	return fileDescriptor_format_e7436119009016db, []int{0}
}
func (m *Format) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Format.Unmarshal(m, b)
}
func (m *Format) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Format.Marshal(b, m, deterministic)
}
func (dst *Format) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Format.Merge(dst, src)
}
func (m *Format) XXX_Size() int {
	return xxx_messageInfo_Format.Size(m)
}
func (m *Format) XXX_DiscardUnknown() {
	xxx_messageInfo_Format.DiscardUnknown(m)
}

var xxx_messageInfo_Format proto.InternalMessageInfo

type isFormat_Type interface {
	isFormat_Type()
}

type Format_Time struct {
	Time *TimeFormat `protobuf:"bytes,1,opt,name=time,proto3,oneof"`
}
type Format_Currency struct {
	Currency *CurrencyFormat `protobuf:"bytes,2,opt,name=currency,proto3,oneof"`
}
type Format_Number struct {
	Number *NumberFormat `protobuf:"bytes,3,opt,name=number,proto3,oneof"`
}

func (*Format_Time) isFormat_Type()     {}
func (*Format_Currency) isFormat_Type() {}
func (*Format_Number) isFormat_Type()   {}

func (m *Format) GetType() isFormat_Type {
	if m != nil {
		return m.Type
	}
	return nil
}

func (m *Format) GetTime() *TimeFormat {
	if x, ok := m.GetType().(*Format_Time); ok {
		return x.Time
	}
	return nil
}

func (m *Format) GetCurrency() *CurrencyFormat {
	if x, ok := m.GetType().(*Format_Currency); ok {
		return x.Currency
	}
	return nil
}

func (m *Format) GetNumber() *NumberFormat {
	if x, ok := m.GetType().(*Format_Number); ok {
		return x.Number
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Format) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Format_OneofMarshaler, _Format_OneofUnmarshaler, _Format_OneofSizer, []interface{}{
		(*Format_Time)(nil),
		(*Format_Currency)(nil),
		(*Format_Number)(nil),
	}
}

func _Format_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Format)
	// type
	switch x := m.Type.(type) {
	case *Format_Time:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Time); err != nil {
			return err
		}
	case *Format_Currency:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Currency); err != nil {
			return err
		}
	case *Format_Number:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Number); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Format.Type has unexpected type %T", x)
	}
	return nil
}

func _Format_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Format)
	switch tag {
	case 1: // type.time
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TimeFormat)
		err := b.DecodeMessage(msg)
		m.Type = &Format_Time{msg}
		return true, err
	case 2: // type.currency
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(CurrencyFormat)
		err := b.DecodeMessage(msg)
		m.Type = &Format_Currency{msg}
		return true, err
	case 3: // type.number
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(NumberFormat)
		err := b.DecodeMessage(msg)
		m.Type = &Format_Number{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Format_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Format)
	// type
	switch x := m.Type.(type) {
	case *Format_Time:
		s := proto.Size(x.Time)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Format_Currency:
		s := proto.Size(x.Currency)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Format_Number:
		s := proto.Size(x.Number)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type TimeFormat struct {
	// Types that are valid to be assigned to Type:
	//	*TimeFormat_Builtin_
	//	*TimeFormat_Imported
	//	*TimeFormat_Custom
	Type isTimeFormat_Type `protobuf_oneof:"type"`
	// only valid on int types, and must set if type is int
	IntUnit              TimeFormat_IntUnit `protobuf:"varint,4,opt,name=intUnit,proto3,enum=pgde.format.TimeFormat_IntUnit" json:"intUnit,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *TimeFormat) Reset()         { *m = TimeFormat{} }
func (m *TimeFormat) String() string { return proto.CompactTextString(m) }
func (*TimeFormat) ProtoMessage()    {}
func (*TimeFormat) Descriptor() ([]byte, []int) {
	return fileDescriptor_format_e7436119009016db, []int{1}
}
func (m *TimeFormat) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_TimeFormat.Unmarshal(m, b)
}
func (m *TimeFormat) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_TimeFormat.Marshal(b, m, deterministic)
}
func (dst *TimeFormat) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TimeFormat.Merge(dst, src)
}
func (m *TimeFormat) XXX_Size() int {
	return xxx_messageInfo_TimeFormat.Size(m)
}
func (m *TimeFormat) XXX_DiscardUnknown() {
	xxx_messageInfo_TimeFormat.DiscardUnknown(m)
}

var xxx_messageInfo_TimeFormat proto.InternalMessageInfo

type isTimeFormat_Type interface {
	isTimeFormat_Type()
}

type TimeFormat_Builtin_ struct {
	Builtin TimeFormat_Builtin `protobuf:"varint,1,opt,name=builtin,proto3,enum=pgde.format.TimeFormat_Builtin,oneof"`
}
type TimeFormat_Imported struct {
	Imported string `protobuf:"bytes,2,opt,name=imported,proto3,oneof"`
}
type TimeFormat_Custom struct {
	Custom string `protobuf:"bytes,3,opt,name=custom,proto3,oneof"`
}

func (*TimeFormat_Builtin_) isTimeFormat_Type() {}
func (*TimeFormat_Imported) isTimeFormat_Type() {}
func (*TimeFormat_Custom) isTimeFormat_Type()   {}

func (m *TimeFormat) GetType() isTimeFormat_Type {
	if m != nil {
		return m.Type
	}
	return nil
}

func (m *TimeFormat) GetBuiltin() TimeFormat_Builtin {
	if x, ok := m.GetType().(*TimeFormat_Builtin_); ok {
		return x.Builtin
	}
	return TimeFormat_mediumDate
}

func (m *TimeFormat) GetImported() string {
	if x, ok := m.GetType().(*TimeFormat_Imported); ok {
		return x.Imported
	}
	return ""
}

func (m *TimeFormat) GetCustom() string {
	if x, ok := m.GetType().(*TimeFormat_Custom); ok {
		return x.Custom
	}
	return ""
}

func (m *TimeFormat) GetIntUnit() TimeFormat_IntUnit {
	if m != nil {
		return m.IntUnit
	}
	return TimeFormat_und
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*TimeFormat) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _TimeFormat_OneofMarshaler, _TimeFormat_OneofUnmarshaler, _TimeFormat_OneofSizer, []interface{}{
		(*TimeFormat_Builtin_)(nil),
		(*TimeFormat_Imported)(nil),
		(*TimeFormat_Custom)(nil),
	}
}

func _TimeFormat_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*TimeFormat)
	// type
	switch x := m.Type.(type) {
	case *TimeFormat_Builtin_:
		b.EncodeVarint(1<<3 | proto.WireVarint)
		b.EncodeVarint(uint64(x.Builtin))
	case *TimeFormat_Imported:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.Imported)
	case *TimeFormat_Custom:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.Custom)
	case nil:
	default:
		return fmt.Errorf("TimeFormat.Type has unexpected type %T", x)
	}
	return nil
}

func _TimeFormat_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*TimeFormat)
	switch tag {
	case 1: // type.builtin
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Type = &TimeFormat_Builtin_{TimeFormat_Builtin(x)}
		return true, err
	case 2: // type.imported
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Type = &TimeFormat_Imported{x}
		return true, err
	case 3: // type.custom
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Type = &TimeFormat_Custom{x}
		return true, err
	default:
		return false, nil
	}
}

func _TimeFormat_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*TimeFormat)
	// type
	switch x := m.Type.(type) {
	case *TimeFormat_Builtin_:
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(x.Builtin))
	case *TimeFormat_Imported:
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(len(x.Imported)))
		n += len(x.Imported)
	case *TimeFormat_Custom:
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(len(x.Custom)))
		n += len(x.Custom)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type CurrencyFormat struct {
	// Types that are valid to be assigned to Type:
	//	*CurrencyFormat_Code
	//	*CurrencyFormat_Symbol
	//	*CurrencyFormat_Name
	Type isCurrencyFormat_Type `protobuf_oneof:"type"`
	// only valid for int currency
	// move decimal point left when showing
	// move decimal point right back when saving
	// need promise the visible fractional digits when showing
	// showing: 1 cent => 0.01 dolar
	// saving: 0.01 dolar => 1 cent
	CentMode             bool     `protobuf:"varint,4,opt,name=centMode,proto3" json:"centMode,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CurrencyFormat) Reset()         { *m = CurrencyFormat{} }
func (m *CurrencyFormat) String() string { return proto.CompactTextString(m) }
func (*CurrencyFormat) ProtoMessage()    {}
func (*CurrencyFormat) Descriptor() ([]byte, []int) {
	return fileDescriptor_format_e7436119009016db, []int{2}
}
func (m *CurrencyFormat) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CurrencyFormat.Unmarshal(m, b)
}
func (m *CurrencyFormat) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CurrencyFormat.Marshal(b, m, deterministic)
}
func (dst *CurrencyFormat) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CurrencyFormat.Merge(dst, src)
}
func (m *CurrencyFormat) XXX_Size() int {
	return xxx_messageInfo_CurrencyFormat.Size(m)
}
func (m *CurrencyFormat) XXX_DiscardUnknown() {
	xxx_messageInfo_CurrencyFormat.DiscardUnknown(m)
}

var xxx_messageInfo_CurrencyFormat proto.InternalMessageInfo

type isCurrencyFormat_Type interface {
	isCurrencyFormat_Type()
}

type CurrencyFormat_Code struct {
	Code CurrencyV1 `protobuf:"varint,1,opt,name=code,proto3,enum=pgde.format.CurrencyV1,oneof"`
}
type CurrencyFormat_Symbol struct {
	Symbol CurrencyV1 `protobuf:"varint,2,opt,name=symbol,proto3,enum=pgde.format.CurrencyV1,oneof"`
}
type CurrencyFormat_Name struct {
	Name CurrencyV1 `protobuf:"varint,3,opt,name=name,proto3,enum=pgde.format.CurrencyV1,oneof"`
}

func (*CurrencyFormat_Code) isCurrencyFormat_Type()   {}
func (*CurrencyFormat_Symbol) isCurrencyFormat_Type() {}
func (*CurrencyFormat_Name) isCurrencyFormat_Type()   {}

func (m *CurrencyFormat) GetType() isCurrencyFormat_Type {
	if m != nil {
		return m.Type
	}
	return nil
}

func (m *CurrencyFormat) GetCode() CurrencyV1 {
	if x, ok := m.GetType().(*CurrencyFormat_Code); ok {
		return x.Code
	}
	return CurrencyV1_XXX
}

func (m *CurrencyFormat) GetSymbol() CurrencyV1 {
	if x, ok := m.GetType().(*CurrencyFormat_Symbol); ok {
		return x.Symbol
	}
	return CurrencyV1_XXX
}

func (m *CurrencyFormat) GetName() CurrencyV1 {
	if x, ok := m.GetType().(*CurrencyFormat_Name); ok {
		return x.Name
	}
	return CurrencyV1_XXX
}

func (m *CurrencyFormat) GetCentMode() bool {
	if m != nil {
		return m.CentMode
	}
	return false
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*CurrencyFormat) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _CurrencyFormat_OneofMarshaler, _CurrencyFormat_OneofUnmarshaler, _CurrencyFormat_OneofSizer, []interface{}{
		(*CurrencyFormat_Code)(nil),
		(*CurrencyFormat_Symbol)(nil),
		(*CurrencyFormat_Name)(nil),
	}
}

func _CurrencyFormat_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*CurrencyFormat)
	// type
	switch x := m.Type.(type) {
	case *CurrencyFormat_Code:
		b.EncodeVarint(1<<3 | proto.WireVarint)
		b.EncodeVarint(uint64(x.Code))
	case *CurrencyFormat_Symbol:
		b.EncodeVarint(2<<3 | proto.WireVarint)
		b.EncodeVarint(uint64(x.Symbol))
	case *CurrencyFormat_Name:
		b.EncodeVarint(3<<3 | proto.WireVarint)
		b.EncodeVarint(uint64(x.Name))
	case nil:
	default:
		return fmt.Errorf("CurrencyFormat.Type has unexpected type %T", x)
	}
	return nil
}

func _CurrencyFormat_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*CurrencyFormat)
	switch tag {
	case 1: // type.code
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Type = &CurrencyFormat_Code{CurrencyV1(x)}
		return true, err
	case 2: // type.symbol
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Type = &CurrencyFormat_Symbol{CurrencyV1(x)}
		return true, err
	case 3: // type.name
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Type = &CurrencyFormat_Name{CurrencyV1(x)}
		return true, err
	default:
		return false, nil
	}
}

func _CurrencyFormat_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*CurrencyFormat)
	// type
	switch x := m.Type.(type) {
	case *CurrencyFormat_Code:
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(x.Code))
	case *CurrencyFormat_Symbol:
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(x.Symbol))
	case *CurrencyFormat_Name:
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(x.Name))
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type NumberFormat struct {
	// Types that are valid to be assigned to Type:
	//	*NumberFormat_Builtin_
	//	*NumberFormat_Imported
	//	*NumberFormat_Custom
	Type                 isNumberFormat_Type `protobuf_oneof:"type"`
	Locale               string              `protobuf:"bytes,4,opt,name=locale,proto3" json:"locale,omitempty"`
	Ordinal              bool                `protobuf:"varint,5,opt,name=ordinal,proto3" json:"ordinal,omitempty"`
	Unit                 *units.Unit         `protobuf:"bytes,6,opt,name=unit,proto3" json:"unit,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *NumberFormat) Reset()         { *m = NumberFormat{} }
func (m *NumberFormat) String() string { return proto.CompactTextString(m) }
func (*NumberFormat) ProtoMessage()    {}
func (*NumberFormat) Descriptor() ([]byte, []int) {
	return fileDescriptor_format_e7436119009016db, []int{3}
}
func (m *NumberFormat) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_NumberFormat.Unmarshal(m, b)
}
func (m *NumberFormat) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_NumberFormat.Marshal(b, m, deterministic)
}
func (dst *NumberFormat) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NumberFormat.Merge(dst, src)
}
func (m *NumberFormat) XXX_Size() int {
	return xxx_messageInfo_NumberFormat.Size(m)
}
func (m *NumberFormat) XXX_DiscardUnknown() {
	xxx_messageInfo_NumberFormat.DiscardUnknown(m)
}

var xxx_messageInfo_NumberFormat proto.InternalMessageInfo

type isNumberFormat_Type interface {
	isNumberFormat_Type()
}

type NumberFormat_Builtin_ struct {
	Builtin NumberFormat_Builtin `protobuf:"varint,1,opt,name=builtin,proto3,enum=pgde.format.NumberFormat_Builtin,oneof"`
}
type NumberFormat_Imported struct {
	Imported string `protobuf:"bytes,2,opt,name=imported,proto3,oneof"`
}
type NumberFormat_Custom struct {
	Custom string `protobuf:"bytes,3,opt,name=custom,proto3,oneof"`
}

func (*NumberFormat_Builtin_) isNumberFormat_Type() {}
func (*NumberFormat_Imported) isNumberFormat_Type() {}
func (*NumberFormat_Custom) isNumberFormat_Type()   {}

func (m *NumberFormat) GetType() isNumberFormat_Type {
	if m != nil {
		return m.Type
	}
	return nil
}

func (m *NumberFormat) GetBuiltin() NumberFormat_Builtin {
	if x, ok := m.GetType().(*NumberFormat_Builtin_); ok {
		return x.Builtin
	}
	return NumberFormat_decimal
}

func (m *NumberFormat) GetImported() string {
	if x, ok := m.GetType().(*NumberFormat_Imported); ok {
		return x.Imported
	}
	return ""
}

func (m *NumberFormat) GetCustom() string {
	if x, ok := m.GetType().(*NumberFormat_Custom); ok {
		return x.Custom
	}
	return ""
}

func (m *NumberFormat) GetLocale() string {
	if m != nil {
		return m.Locale
	}
	return ""
}

func (m *NumberFormat) GetOrdinal() bool {
	if m != nil {
		return m.Ordinal
	}
	return false
}

func (m *NumberFormat) GetUnit() *units.Unit {
	if m != nil {
		return m.Unit
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*NumberFormat) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _NumberFormat_OneofMarshaler, _NumberFormat_OneofUnmarshaler, _NumberFormat_OneofSizer, []interface{}{
		(*NumberFormat_Builtin_)(nil),
		(*NumberFormat_Imported)(nil),
		(*NumberFormat_Custom)(nil),
	}
}

func _NumberFormat_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*NumberFormat)
	// type
	switch x := m.Type.(type) {
	case *NumberFormat_Builtin_:
		b.EncodeVarint(1<<3 | proto.WireVarint)
		b.EncodeVarint(uint64(x.Builtin))
	case *NumberFormat_Imported:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.Imported)
	case *NumberFormat_Custom:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.Custom)
	case nil:
	default:
		return fmt.Errorf("NumberFormat.Type has unexpected type %T", x)
	}
	return nil
}

func _NumberFormat_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*NumberFormat)
	switch tag {
	case 1: // type.builtin
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Type = &NumberFormat_Builtin_{NumberFormat_Builtin(x)}
		return true, err
	case 2: // type.imported
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Type = &NumberFormat_Imported{x}
		return true, err
	case 3: // type.custom
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Type = &NumberFormat_Custom{x}
		return true, err
	default:
		return false, nil
	}
}

func _NumberFormat_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*NumberFormat)
	// type
	switch x := m.Type.(type) {
	case *NumberFormat_Builtin_:
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(x.Builtin))
	case *NumberFormat_Imported:
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(len(x.Imported)))
		n += len(x.Imported)
	case *NumberFormat_Custom:
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(len(x.Custom)))
		n += len(x.Custom)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

var E_Format = &proto.ExtensionDesc{
	ExtendedType:  (*descriptor.FieldOptions)(nil),
	ExtensionType: (*Format)(nil),
	Field:         919111,
	Name:          "pgde.format.format",
	Tag:           "bytes,919111,opt,name=format",
	Filename:      "protos/format/format.proto",
}

func init() {
	proto.RegisterType((*Format)(nil), "pgde.format.Format")
	proto.RegisterType((*TimeFormat)(nil), "pgde.format.TimeFormat")
	proto.RegisterType((*CurrencyFormat)(nil), "pgde.format.CurrencyFormat")
	proto.RegisterType((*NumberFormat)(nil), "pgde.format.NumberFormat")
	proto.RegisterEnum("pgde.format.TimeFormat_Builtin", TimeFormat_Builtin_name, TimeFormat_Builtin_value)
	proto.RegisterEnum("pgde.format.TimeFormat_IntUnit", TimeFormat_IntUnit_name, TimeFormat_IntUnit_value)
	proto.RegisterEnum("pgde.format.NumberFormat_Builtin", NumberFormat_Builtin_name, NumberFormat_Builtin_value)
	proto.RegisterExtension(E_Format)
}

func init() { proto.RegisterFile("protos/format/format.proto", fileDescriptor_format_e7436119009016db) }

var fileDescriptor_format_e7436119009016db = []byte{
	// 698 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xac, 0x54, 0xcd, 0x6e, 0xd3, 0x40,
	0x10, 0xae, 0xf3, 0x63, 0xbb, 0x93, 0x2a, 0x35, 0x5b, 0x41, 0x4d, 0x28, 0xa2, 0x44, 0x1c, 0xb8,
	0xc4, 0x51, 0x5b, 0x90, 0xf8, 0x11, 0x97, 0x52, 0x55, 0x45, 0xe2, 0x47, 0x0a, 0x94, 0x03, 0x37,
	0xc7, 0xde, 0xa4, 0xab, 0xda, 0xbb, 0xd6, 0x66, 0x57, 0x34, 0xef, 0xc0, 0x43, 0xf0, 0x06, 0xbc,
	0x00, 0x57, 0xc4, 0x7b, 0xf0, 0x24, 0xec, 0x9f, 0xd3, 0x04, 0xd1, 0x72, 0xe1, 0x92, 0xec, 0xcc,
	0x7c, 0x33, 0xfb, 0xcd, 0xec, 0xe7, 0x81, 0x5e, 0xc5, 0x99, 0x60, 0xb3, 0xe1, 0x84, 0xf1, 0x32,
	0x15, 0xee, 0x2f, 0x31, 0x4e, 0xd4, 0xa9, 0xa6, 0x39, 0x4e, 0xac, 0xab, 0xb7, 0x3b, 0x65, 0x6c,
	0x5a, 0xe0, 0xa1, 0x09, 0x8d, 0xe5, 0x64, 0x98, 0xe3, 0x59, 0xc6, 0x49, 0x25, 0x18, 0xb7, 0xf0,
	0xde, 0xce, 0x6a, 0xa9, 0x4c, 0x72, 0x8e, 0x69, 0x36, 0x77, 0xd1, 0xd8, 0x45, 0x25, 0x25, 0xc2,
	0xfd, 0xda, 0x48, 0xff, 0x9b, 0x07, 0xfe, 0xb1, 0xc9, 0x41, 0x03, 0x68, 0x09, 0x52, 0xe2, 0xd8,
	0xdb, 0xf5, 0x1e, 0x76, 0xf6, 0xb7, 0x93, 0x25, 0x02, 0xc9, 0x07, 0x15, 0xb0, 0xb0, 0x93, 0xb5,
	0x91, 0x81, 0xa1, 0xa7, 0x10, 0xd6, 0xb7, 0xc4, 0x0d, 0x93, 0x72, 0x67, 0x25, 0xe5, 0xa5, 0x0b,
	0x2e, 0xd2, 0x16, 0x70, 0x74, 0x00, 0x3e, 0x95, 0xe5, 0x18, 0xf3, 0xb8, 0x69, 0x12, 0x6f, 0xaf,
	0x24, 0xbe, 0x35, 0xa1, 0x45, 0x9a, 0x83, 0x1e, 0xfa, 0x8a, 0xde, 0xbc, 0xc2, 0xfd, 0x5f, 0x4d,
	0x80, 0x4b, 0x3a, 0xe8, 0x39, 0x04, 0x63, 0x49, 0x0a, 0x41, 0xa8, 0x21, 0xde, 0xdd, 0xbf, 0x77,
	0x05, 0xf1, 0xe4, 0xd0, 0xc2, 0x54, 0xc9, 0x3a, 0x03, 0xed, 0x40, 0x48, 0xca, 0x8a, 0x71, 0x81,
	0x73, 0xd3, 0xc3, 0xba, 0xa6, 0x59, 0x7b, 0x50, 0x0c, 0x7e, 0x26, 0x67, 0x82, 0x95, 0x86, 0xa6,
	0x8e, 0x39, 0x5b, 0xf5, 0x1e, 0x10, 0x2a, 0x4e, 0xd5, 0x1c, 0xe3, 0xd6, 0xf5, 0x97, 0xbe, 0xb2,
	0xb0, 0x51, 0x8d, 0xef, 0x7f, 0xf5, 0x20, 0x70, 0x4c, 0x50, 0x17, 0xa0, 0xc4, 0x39, 0x91, 0xe5,
	0x51, 0x2a, 0x70, 0xb4, 0x86, 0x36, 0x20, 0x9c, 0xc8, 0xa2, 0x50, 0x56, 0x1a, 0x79, 0x68, 0x1d,
	0xda, 0x6c, 0x72, 0x94, 0xce, 0xa3, 0x86, 0x0e, 0x98, 0xe3, 0xfe, 0xa3, 0x93, 0xa8, 0x89, 0x10,
	0x74, 0x2f, 0xd3, 0xf4, 0x5b, 0x44, 0x2d, 0x74, 0x13, 0x6e, 0xac, 0xfa, 0x34, 0xb4, 0x8d, 0x22,
	0xd8, 0x70, 0x15, 0x2d, 0xd0, 0x47, 0x5b, 0xb0, 0xb9, 0xec, 0xd1, 0xb0, 0x40, 0xd7, 0xcf, 0x25,
	0x4f, 0x05, 0x61, 0x34, 0x0a, 0xfb, 0x73, 0x08, 0x1c, 0x6d, 0x14, 0x40, 0x53, 0xd2, 0x5c, 0x51,
	0x53, 0x54, 0x69, 0x4a, 0xd9, 0x0c, 0x67, 0x4c, 0xd9, 0x1e, 0xda, 0x84, 0x4e, 0x49, 0x32, 0x5e,
	0x3b, 0x1a, 0xd6, 0x51, 0x14, 0xc4, 0x39, 0x9a, 0x08, 0xc0, 0x77, 0xe7, 0x96, 0x3e, 0x97, 0x84,
	0x4a, 0xd5, 0x64, 0x1b, 0x85, 0xd0, 0x3a, 0x63, 0x92, 0x2b, 0x2a, 0xaa, 0x78, 0xae, 0xda, 0x0b,
	0xb4, 0xeb, 0x33, 0xc6, 0xe7, 0x51, 0xb8, 0x78, 0xe4, 0x1f, 0x1e, 0x74, 0x57, 0x05, 0xa4, 0xe5,
	0x99, 0xb1, 0x1c, 0xbb, 0x57, 0xde, 0xfe, 0xab, 0xd6, 0x3e, 0xee, 0x69, 0x79, 0x6a, 0x18, 0xda,
	0x53, 0xd7, 0xcf, 0xcb, 0x31, 0x2b, 0xcc, 0xc3, 0x5e, 0x9b, 0xe0, 0x80, 0xfa, 0x06, 0x9a, 0xaa,
	0x0f, 0xa0, 0xf9, 0xcf, 0x1b, 0x34, 0x0c, 0xf5, 0xd4, 0x07, 0x80, 0xa9, 0x78, 0xa3, 0x49, 0x69,
	0x15, 0x84, 0xa3, 0x85, 0xbd, 0xe8, 0xe3, 0x7b, 0x03, 0x36, 0x96, 0xf5, 0x8c, 0x5e, 0xfc, 0x29,
	0xd7, 0xfb, 0x57, 0x6a, 0xff, 0x7f, 0x0a, 0xf6, 0x16, 0xf8, 0x05, 0xcb, 0xd2, 0xc2, 0x32, 0x5d,
	0x1f, 0x39, 0x4b, 0x65, 0x04, 0x8c, 0xe7, 0x84, 0xa6, 0x45, 0xdc, 0x36, 0x2d, 0xd4, 0x26, 0x7a,
	0x00, 0x2d, 0xbd, 0x27, 0x62, 0xdf, 0x7c, 0xa1, 0x91, 0x65, 0x69, 0x37, 0x87, 0x11, 0xb4, 0x89,
	0xf6, 0x4f, 0x2f, 0xc5, 0xdc, 0x81, 0x20, 0xc7, 0x19, 0x29, 0xd3, 0x42, 0xc9, 0x45, 0x19, 0x15,
	0xe6, 0x7a, 0x1c, 0x4a, 0x2b, 0x4a, 0x3b, 0xb3, 0x8c, 0xa8, 0x33, 0x99, 0x90, 0xcc, 0xaa, 0xb9,
	0x5e, 0x05, 0x56, 0xcd, 0xb5, 0xf5, 0x5e, 0x75, 0x52, 0x28, 0x35, 0xd7, 0xe3, 0x7b, 0xf6, 0x1a,
	0x7c, 0x3b, 0x18, 0x74, 0x37, 0xb1, 0x2b, 0x30, 0xa9, 0x57, 0x60, 0x72, 0x4c, 0x70, 0x91, 0xbf,
	0xab, 0xb4, 0x66, 0x67, 0xf1, 0xcf, 0x2f, 0x4f, 0x0c, 0xcf, 0xad, 0x95, 0x69, 0xda, 0x39, 0x8e,
	0x5c, 0x8d, 0xc3, 0xc7, 0x9f, 0x0e, 0xa6, 0x44, 0x9c, 0xc9, 0x71, 0x92, 0xb1, 0x72, 0x88, 0xcb,
	0x8a, 0x70, 0x3c, 0x61, 0x17, 0x76, 0xab, 0x66, 0x83, 0x29, 0xa6, 0x83, 0x3c, 0xe5, 0x62, 0x80,
	0x2f, 0xc4, 0xb0, 0x3a, 0x9f, 0xba, 0x5d, 0x3a, 0xf6, 0x4d, 0xfc, 0xe0, 0x77, 0x00, 0x00, 0x00,
	0xff, 0xff, 0xfa, 0x14, 0x3c, 0x98, 0xae, 0x05, 0x00, 0x00,
}
