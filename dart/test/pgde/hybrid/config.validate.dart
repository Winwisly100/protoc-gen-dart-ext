// DO NOT EDIT. Generated by protoc-gen-dart-ext/tools.

/// Code generated by protoc-gen-dart-ext. DO NOT EDIT.
/// source: hybrid/config.proto
// ignore_for_file: non_constant_identifier_names,unnecessary_brace_in_string_interps,unused_local_variable

import 'dart:collection' as $0 show HashSet;
import 'dart:convert' as $1 show utf8;
import 'package:flutter/material.dart' as $3 show BuildContext, Localizations;
import 'package:pgde/pgde.dart' as $6
    show
        BeSomethingError,
        ConstError,
        GeneratedValidator,
        InError,
        LenConstError,
        Lists,
        OneofRequiredError,
        RequiredError,
        ValidateInfo;
import 'config.pb.dart' as $7
    show
        AdpRouter,
        Basic,
        Config,
        FileServer,
        HttpProxyServer,
        IPNetRouter,
        Ipfs,
        IpfsServer,
        Log,
        RouterItem,
        RouterItem_Router;
import 'config.l10n.dart' as $8 show ConfigLocalizations;

/// Validates [$7.Basic] protobuf objects.
class BasicValidator extends $6.GeneratedValidator<$7.Basic> {
  void assertProto() {
    assertField_version();
    assertField_dev();
    assertField_enableBind();
    assertField_bindIp();
    assertField_bindPort();
    assertField_flushIntervalMs();
    assertField_token();
  }

  void assertField(int tag) {
    switch (tag) {
      case 1:
        return assertField_version();
      case 2:
        return assertField_dev();
      case 3:
        return assertField_enableBind();
      case 4:
        return assertField_bindIp();
      case 5:
        return assertField_bindPort();
      case 6:
        return assertField_flushIntervalMs();
      case 7:
        return assertField_token();

      default:
        throw ArgumentError.value(
            'tag number($tag) for ${_info.bi.messageName} not found');
    }
  }

  void assertField_version() {
    // no validation rules for version
  }
  void assertField_dev() {
    // no validation rules for dev
  }
  void assertField_enableBind() {
    // no validation rules for enableBind
  }
  void assertField_bindIp() {
    final _v = _info.proto.bindIp;

    try {
      Uri.parseIPv4Address(_v);
    } on FormatException {
      try {
        Uri.parseIPv6Address(_v);
      } on FormatException {
        throw $6.BeSomethingError(
            _info, 4, _l10n.BasicBindIp, _info.l10n.validateIp);
      }
    }
  }

  void assertField_bindPort() {
    final _v = _info.proto.bindPort;

    if (_v >= 65535)
      throw $6.ConstError(
          _info, 5, _l10n.BasicBindPort, _info.l10n.validateLt, 65535);
  }

  void assertField_flushIntervalMs() {
    // no validation rules for flushIntervalMs
  }
  void assertField_token() {
    final _v = _info.proto.token;

    final _vbl = $6.Lists.len($1.utf8.encode(_v));

    if (_vbl > 732)
      throw $6.LenConstError.byte(
          _info, 7, _l10n.BasicToken, _info.l10n.validateLte, 732);
  }

  void assertOneof(Type oneof) {
    switch (oneof) {
      default:
        throw ArgumentError.value(
            'oneof type($oneof) for ${_info.bi.messageName} not found');
    }
  }

  $3.BuildContext _ctx;

  $6.ValidateInfo<$7.Basic> _info;

  $8.ConfigLocalizations _l10n;

  BasicValidator($3.BuildContext context, $6.ValidateInfo<$7.Basic> info)
      : _ctx = context,
        _info = info,
        _l10n = $3.Localizations.of<$8.ConfigLocalizations>(
            context, $8.ConfigLocalizations);
}

/// Validates [$7.Log] protobuf objects.
class LogValidator extends $6.GeneratedValidator<$7.Log> {
  static const Map<String, Null> _levelIn = {
    r'': null,
    r'debug': null,
    r'info': null,
    r'warn': null,
    r'error': null,
    r'dpanic': null,
    r'panic': null,
    r'fatal': null,
  };

  void assertProto() {
    assertField_dev();
    assertField_level();
    assertField_target();
  }

  void assertField(int tag) {
    switch (tag) {
      case 1:
        return assertField_dev();
      case 2:
        return assertField_level();
      case 3:
        return assertField_target();

      default:
        throw ArgumentError.value(
            'tag number($tag) for ${_info.bi.messageName} not found');
    }
  }

  void assertField_dev() {
    // no validation rules for dev
  }
  void assertField_level() {
    final _v = _info.proto.level;

    if (!_levelIn.containsKey(_v))
      throw $6.InError(_info, 2, _l10n.LogLevel, _levelIn.keys.toList());
  }

  void assertField_target() {
    // no validation rules for target
  }
  void assertOneof(Type oneof) {
    switch (oneof) {
      default:
        throw ArgumentError.value(
            'oneof type($oneof) for ${_info.bi.messageName} not found');
    }
  }

  $3.BuildContext _ctx;

  $6.ValidateInfo<$7.Log> _info;

  $8.ConfigLocalizations _l10n;

  LogValidator($3.BuildContext context, $6.ValidateInfo<$7.Log> info)
      : _ctx = context,
        _info = info,
        _l10n = $3.Localizations.of<$8.ConfigLocalizations>(
            context, $8.ConfigLocalizations);
}

/// Validates [$7.Ipfs] protobuf objects.
class IpfsValidator extends $6.GeneratedValidator<$7.Ipfs> {
  void assertProto() {
    assertField_fakeApiListenIp();
    assertField_fakeApiListenPort();
    assertField_enableGateway();
    assertField_gatewayServerName();
    assertField_enableApi();
    assertField_apiServerName();
    assertField_profile();
    assertField_autoMigrate();
    assertField_enableIpnsPubSub();
    assertField_enablePubSub();
    assertField_enableMultiplex();
    assertField_token();
  }

  void assertField(int tag) {
    switch (tag) {
      case 1:
        return assertField_fakeApiListenIp();
      case 2:
        return assertField_fakeApiListenPort();
      case 3:
        return assertField_enableGateway();
      case 4:
        return assertField_gatewayServerName();
      case 5:
        return assertField_enableApi();
      case 6:
        return assertField_apiServerName();
      case 7:
        return assertField_profile();
      case 8:
        return assertField_autoMigrate();
      case 9:
        return assertField_enableIpnsPubSub();
      case 10:
        return assertField_enablePubSub();
      case 11:
        return assertField_enableMultiplex();
      case 12:
        return assertField_token();

      default:
        throw ArgumentError.value(
            'tag number($tag) for ${_info.bi.messageName} not found');
    }
  }

  void assertField_fakeApiListenIp() {
    final _v = _info.proto.fakeApiListenIp;

    try {
      Uri.parseIPv4Address(_v);
    } on FormatException {
      try {
        Uri.parseIPv6Address(_v);
      } on FormatException {
        throw $6.BeSomethingError(
            _info, 1, _l10n.IpfsFakeApiListenIp, _info.l10n.validateIp);
      }
    }
  }

  void assertField_fakeApiListenPort() {
    final _v = _info.proto.fakeApiListenPort;

    if (_v >= 65535)
      throw $6.ConstError(
          _info, 2, _l10n.IpfsFakeApiListenPort, _info.l10n.validateLt, 65535);
  }

  void assertField_enableGateway() {
    // no validation rules for enableGateway
  }
  void assertField_gatewayServerName() {
    final _v = _info.proto.gatewayServerName;

    try {
      Uri(host: _v);
    } on FormatException {
      throw $6.BeSomethingError(
          _info, 4, _l10n.IpfsGatewayServerName, _info.l10n.validateHostname);
    }
  }

  void assertField_enableApi() {
    // no validation rules for enableApi
  }
  void assertField_apiServerName() {
    final _v = _info.proto.apiServerName;

    try {
      Uri(host: _v);
    } on FormatException {
      throw $6.BeSomethingError(
          _info, 6, _l10n.IpfsApiServerName, _info.l10n.validateHostname);
    }
  }

  void assertField_profile() {
    final _v = _info.proto.profile;

    final Set<String> _unique = $0.HashSet();

    for (var _ridx = 0; _ridx < _v.length; _ridx++) {
      final _ritem = _v[_ridx];

      if (!_unique.add(_ritem))
        throw $6.BeSomethingError(
            _info, 7, _l10n.IpfsProfile, _info.l10n.validateUnique(_ridx + 1));

      // no validation rules for profile

    }
  }

  void assertField_autoMigrate() {
    // no validation rules for autoMigrate
  }
  void assertField_enableIpnsPubSub() {
    // no validation rules for enableIpnsPubSub
  }
  void assertField_enablePubSub() {
    // no validation rules for enablePubSub
  }
  void assertField_enableMultiplex() {
    // no validation rules for enableMultiplex
  }
  void assertField_token() {
    final _v = _info.proto.token;

    final _vbl = $6.Lists.len($1.utf8.encode(_v));

    if (_vbl > 732)
      throw $6.LenConstError.byte(
          _info, 12, _l10n.IpfsToken, _info.l10n.validateLte, 732);
  }

  void assertOneof(Type oneof) {
    switch (oneof) {
      default:
        throw ArgumentError.value(
            'oneof type($oneof) for ${_info.bi.messageName} not found');
    }
  }

  $3.BuildContext _ctx;

  $6.ValidateInfo<$7.Ipfs> _info;

  $8.ConfigLocalizations _l10n;

  IpfsValidator($3.BuildContext context, $6.ValidateInfo<$7.Ipfs> info)
      : _ctx = context,
        _info = info,
        _l10n = $3.Localizations.of<$8.ConfigLocalizations>(
            context, $8.ConfigLocalizations);
}

/// Validates [$7.IpfsServer] protobuf objects.
class IpfsServerValidator extends $6.GeneratedValidator<$7.IpfsServer> {
  void assertProto() {
    assertField_disabled();
    assertField_name();
    assertField_peer();
    assertField_token();
  }

  void assertField(int tag) {
    switch (tag) {
      case 1:
        return assertField_disabled();
      case 2:
        return assertField_name();
      case 3:
        return assertField_peer();
      case 4:
        return assertField_token();

      default:
        throw ArgumentError.value(
            'tag number($tag) for ${_info.bi.messageName} not found');
    }
  }

  void assertField_disabled() {
    // no validation rules for disabled
  }
  void assertField_name() {
    final _v = _info.proto.name;

    if (_info.proto.hasName()) {
      try {
        Uri(host: _v.value);
      } on FormatException {
        throw $6.BeSomethingError(
            _info, 2, _l10n.IpfsServerName, _info.l10n.validateHostname);
      }
    }
  }

  void assertField_peer() {
    final _v = _info.proto.peer;

    try {
      Uri(host: _v);
    } on FormatException {
      throw $6.BeSomethingError(
          _info, 3, _l10n.IpfsServerPeer, _info.l10n.validateHostname);
    }
  }

  void assertField_token() {
    final _v = _info.proto.token;

    final _vbl = $6.Lists.len($1.utf8.encode(_v));

    if (_vbl > 732)
      throw $6.LenConstError.byte(
          _info, 4, _l10n.IpfsServerToken, _info.l10n.validateLte, 732);
  }

  void assertOneof(Type oneof) {
    switch (oneof) {
      default:
        throw ArgumentError.value(
            'oneof type($oneof) for ${_info.bi.messageName} not found');
    }
  }

  $3.BuildContext _ctx;

  $6.ValidateInfo<$7.IpfsServer> _info;

  $8.ConfigLocalizations _l10n;

  IpfsServerValidator(
      $3.BuildContext context, $6.ValidateInfo<$7.IpfsServer> info)
      : _ctx = context,
        _info = info,
        _l10n = $3.Localizations.of<$8.ConfigLocalizations>(
            context, $8.ConfigLocalizations);
}

/// Validates [$7.FileServer] protobuf objects.
class FileServerValidator extends $6.GeneratedValidator<$7.FileServer> {
  void assertProto() {
    assertField_disabled();
    assertField_name();
    assertField_zip();
    assertField_redirect();
    assertField_dev();
  }

  void assertField(int tag) {
    switch (tag) {
      case 1:
        return assertField_disabled();
      case 2:
        return assertField_name();
      case 3:
        return assertField_zip();
      case 4:
        return assertField_redirect();
      case 5:
        return assertField_dev();

      default:
        throw ArgumentError.value(
            'tag number($tag) for ${_info.bi.messageName} not found');
    }
  }

  void assertField_disabled() {
    // no validation rules for disabled
  }
  void assertField_name() {
    final _v = _info.proto.name;

    if (_info.proto.hasName()) {
      try {
        Uri(host: _v.value);
      } on FormatException {
        throw $6.BeSomethingError(
            _info, 2, _l10n.FileServerName, _info.l10n.validateHostname);
      }
    }
  }

  void assertField_zip() {
    final _v = _info.proto.zip;

    try {
      Uri(host: _v);
    } on FormatException {
      throw $6.BeSomethingError(
          _info, 3, _l10n.FileServerZip, _info.l10n.validateHostname);
    }
  }

  void assertField_redirect() {
    final _v = _info.proto.redirect;

    _v.forEach((_mk, _mv) {
      try {
        Uri.parse(_mk);
      } on FormatException {
        throw $6.BeSomethingError(_info, 4,
            '`${_l10n.FileServerRedirect}[${_mk}]`', _info.l10n.validateUri);
      }

      try {
        Uri.parse(_mv);
      } on FormatException {
        throw $6.BeSomethingError(_info, 4,
            '`${_l10n.FileServerRedirect}[${_mk}]`', _info.l10n.validateUri);
      }
    });
  }

  void assertField_dev() {
    // no validation rules for dev
  }
  void assertOneof(Type oneof) {
    switch (oneof) {
      default:
        throw ArgumentError.value(
            'oneof type($oneof) for ${_info.bi.messageName} not found');
    }
  }

  $3.BuildContext _ctx;

  $6.ValidateInfo<$7.FileServer> _info;

  $8.ConfigLocalizations _l10n;

  FileServerValidator(
      $3.BuildContext context, $6.ValidateInfo<$7.FileServer> info)
      : _ctx = context,
        _info = info,
        _l10n = $3.Localizations.of<$8.ConfigLocalizations>(
            context, $8.ConfigLocalizations);
}

/// Validates [$7.HttpProxyServer] protobuf objects.
class HttpProxyServerValidator
    extends $6.GeneratedValidator<$7.HttpProxyServer> {
  void assertProto() {
    assertField_disabled();
    assertField_name();
    assertField_host();
    assertField_port();
    assertField_keepAlive();
  }

  void assertField(int tag) {
    switch (tag) {
      case 1:
        return assertField_disabled();
      case 2:
        return assertField_name();
      case 3:
        return assertField_host();
      case 4:
        return assertField_port();
      case 5:
        return assertField_keepAlive();

      default:
        throw ArgumentError.value(
            'tag number($tag) for ${_info.bi.messageName} not found');
    }
  }

  void assertField_disabled() {
    // no validation rules for disabled
  }
  void assertField_name() {
    final _v = _info.proto.name;

    if (_info.proto.hasName()) {
      try {
        Uri(host: _v.value);
      } on FormatException {
        throw $6.BeSomethingError(
            _info, 2, _l10n.HttpProxyServerName, _info.l10n.validateHostname);
      }
    }
  }

  void assertField_host() {
    final _v = _info.proto.host;

    try {
      Uri.parseIPv4Address(_v);
    } on FormatException {
      try {
        Uri.parseIPv6Address(_v);
      } on FormatException {
        throw $6.BeSomethingError(
            _info, 3, _l10n.HttpProxyServerHost, _info.l10n.validateIp);
      }
    }
  }

  void assertField_port() {
    final _v = _info.proto.port;

    if (_v >= 65535)
      throw $6.ConstError(
          _info, 4, _l10n.HttpProxyServerPort, _info.l10n.validateLt, 65535);
  }

  void assertField_keepAlive() {
    // no validation rules for keepAlive
  }
  void assertOneof(Type oneof) {
    switch (oneof) {
      default:
        throw ArgumentError.value(
            'oneof type($oneof) for ${_info.bi.messageName} not found');
    }
  }

  $3.BuildContext _ctx;

  $6.ValidateInfo<$7.HttpProxyServer> _info;

  $8.ConfigLocalizations _l10n;

  HttpProxyServerValidator(
      $3.BuildContext context, $6.ValidateInfo<$7.HttpProxyServer> info)
      : _ctx = context,
        _info = info,
        _l10n = $3.Localizations.of<$8.ConfigLocalizations>(
            context, $8.ConfigLocalizations);
}

/// Validates [$7.AdpRouter] protobuf objects.
class AdpRouterValidator extends $6.GeneratedValidator<$7.AdpRouter> {
  void assertProto() {
    assertField_rulesDirName();
    assertField_blocked();
    assertField_unblocked();
    assertField_etcHostsIpAsBlocked();
    assertField_dev();
  }

  void assertField(int tag) {
    switch (tag) {
      case 1:
        return assertField_rulesDirName();
      case 2:
        return assertField_blocked();
      case 3:
        return assertField_unblocked();
      case 4:
        return assertField_etcHostsIpAsBlocked();
      case 5:
        return assertField_dev();

      default:
        throw ArgumentError.value(
            'tag number($tag) for ${_info.bi.messageName} not found');
    }
  }

  void assertField_rulesDirName() {
    // no validation rules for rulesDirName
  }
  void assertField_blocked() {
    final _v = _info.proto.blocked;

    if (_info.proto.hasBlocked()) {
      try {
        Uri(host: _v.value);
      } on FormatException {
        throw $6.BeSomethingError(
            _info, 2, _l10n.AdpRouterBlocked, _info.l10n.validateHostname);
      }
    }
  }

  void assertField_unblocked() {
    final _v = _info.proto.unblocked;

    if (_info.proto.hasUnblocked()) {
      try {
        Uri(host: _v.value);
      } on FormatException {
        throw $6.BeSomethingError(
            _info, 3, _l10n.AdpRouterUnblocked, _info.l10n.validateHostname);
      }
    }
  }

  void assertField_etcHostsIpAsBlocked() {
    // no validation rules for etcHostsIpAsBlocked
  }
  void assertField_dev() {
    // no validation rules for dev
  }
  void assertOneof(Type oneof) {
    switch (oneof) {
      default:
        throw ArgumentError.value(
            'oneof type($oneof) for ${_info.bi.messageName} not found');
    }
  }

  $3.BuildContext _ctx;

  $6.ValidateInfo<$7.AdpRouter> _info;

  $8.ConfigLocalizations _l10n;

  AdpRouterValidator(
      $3.BuildContext context, $6.ValidateInfo<$7.AdpRouter> info)
      : _ctx = context,
        _info = info,
        _l10n = $3.Localizations.of<$8.ConfigLocalizations>(
            context, $8.ConfigLocalizations);
}

/// Validates [$7.IPNetRouter] protobuf objects.
class IPNetRouterValidator extends $6.GeneratedValidator<$7.IPNetRouter> {
  void assertProto() {
    assertField_ip();
    assertField_net();
    assertField_matched();
    assertField_unmatched();
    assertField_fileTest();
  }

  void assertField(int tag) {
    switch (tag) {
      case 1:
        return assertField_ip();
      case 2:
        return assertField_net();
      case 3:
        return assertField_matched();
      case 4:
        return assertField_unmatched();
      case 5:
        return assertField_fileTest();

      default:
        throw ArgumentError.value(
            'tag number($tag) for ${_info.bi.messageName} not found');
    }
  }

  void assertField_ip() {
    final _v = _info.proto.ip;
  }

  void assertField_net() {
    final _v = _info.proto.net;
  }

  void assertField_matched() {
    // no validation rules for matched
  }
  void assertField_unmatched() {
    // no validation rules for unmatched
  }
  void assertField_fileTest() {
    // no validation rules for fileTest
  }
  void assertOneof(Type oneof) {
    switch (oneof) {
      default:
        throw ArgumentError.value(
            'oneof type($oneof) for ${_info.bi.messageName} not found');
    }
  }

  $3.BuildContext _ctx;

  $6.ValidateInfo<$7.IPNetRouter> _info;

  $8.ConfigLocalizations _l10n;

  IPNetRouterValidator(
      $3.BuildContext context, $6.ValidateInfo<$7.IPNetRouter> info)
      : _ctx = context,
        _info = info,
        _l10n = $3.Localizations.of<$8.ConfigLocalizations>(
            context, $8.ConfigLocalizations);
}

/// Validates [$7.RouterItem] protobuf objects.
class RouterItemValidator extends $6.GeneratedValidator<$7.RouterItem> {
  void assertProto() {
    assertField_disabled();
    assertField_name();

    assertOneof_Router();
  }

  void assertField(int tag) {
    switch (tag) {
      case 1:
        return assertField_disabled();
      case 2:
        return assertField_name();
      case 3:
        return assertField_adp();
      case 4:
        return assertField_ipnet();

      default:
        throw ArgumentError.value(
            'tag number($tag) for ${_info.bi.messageName} not found');
    }
  }

  void assertField_disabled() {
    // no validation rules for disabled
  }
  void assertField_name() {
    final _v = _info.proto.name;

    try {
      Uri(host: _v);
    } on FormatException {
      throw $6.BeSomethingError(
          _info, 2, _l10n.RouterItemName, _info.l10n.validateHostname);
    }
  }

  void assertField_adp() {
    final _v = _info.proto.adp;

    AdpRouterValidator(_ctx, _info.clone(_v)).assertProto();
  }

  void assertField_ipnet() {
    final _v = _info.proto.ipnet;

    IPNetRouterValidator(_ctx, _info.clone(_v)).assertProto();
  }

  void assertOneof(Type oneof) {
    switch (oneof) {
      case $7.RouterItem_Router:
        return assertOneof_Router();

      default:
        throw ArgumentError.value(
            'oneof type($oneof) for ${_info.bi.messageName} not found');
    }
  }

  void assertOneof_Router() {
    switch (_info.proto.whichRouter()) {
      case $7.RouterItem_Router.adp:
        assertField_adp();
        break;
      case $7.RouterItem_Router.ipnet:
        assertField_ipnet();
        break;

      default:
        throw $6.OneofRequiredError(_info, _l10n.RouterItemRouter);
    }
  }

  $3.BuildContext _ctx;

  $6.ValidateInfo<$7.RouterItem> _info;

  $8.ConfigLocalizations _l10n;

  RouterItemValidator(
      $3.BuildContext context, $6.ValidateInfo<$7.RouterItem> info)
      : _ctx = context,
        _info = info,
        _l10n = $3.Localizations.of<$8.ConfigLocalizations>(
            context, $8.ConfigLocalizations);
}

/// Validates [$7.Config] protobuf objects.
class ConfigValidator extends $6.GeneratedValidator<$7.Config> {
  void assertProto() {
    assertField_basic();
    assertField_log();
    assertField_ipfs();
    assertField_ipfsServers();
    assertField_fileServers();
    assertField_httpProxyServers();
    assertField_routers();
  }

  void assertField(int tag) {
    switch (tag) {
      case 1:
        return assertField_basic();
      case 2:
        return assertField_log();
      case 3:
        return assertField_ipfs();
      case 4:
        return assertField_ipfsServers();
      case 5:
        return assertField_fileServers();
      case 6:
        return assertField_httpProxyServers();
      case 7:
        return assertField_routers();

      default:
        throw ArgumentError.value(
            'tag number($tag) for ${_info.bi.messageName} not found');
    }
  }

  void assertField_basic() {
    final _v = _info.proto.basic;

    if (_v == null) throw $6.RequiredError(_info, 1, _l10n.ConfigBasic);

    BasicValidator(_ctx, _info.clone(_v)).assertProto();
  }

  void assertField_log() {
    final _v = _info.proto.log;

    LogValidator(_ctx, _info.clone(_v)).assertProto();
  }

  void assertField_ipfs() {
    final _v = _info.proto.ipfs;

    IpfsValidator(_ctx, _info.clone(_v)).assertProto();
  }

  void assertField_ipfsServers() {
    final _v = _info.proto.ipfsServers;

    for (var _ridx = 0; _ridx < _v.length; _ridx++) {
      final _ritem = _v[_ridx];

      IpfsServerValidator(_ctx, _info.clone(_ritem)).assertProto();
    }
  }

  void assertField_fileServers() {
    final _v = _info.proto.fileServers;

    for (var _ridx = 0; _ridx < _v.length; _ridx++) {
      final _ritem = _v[_ridx];

      FileServerValidator(_ctx, _info.clone(_ritem)).assertProto();
    }
  }

  void assertField_httpProxyServers() {
    final _v = _info.proto.httpProxyServers;

    for (var _ridx = 0; _ridx < _v.length; _ridx++) {
      final _ritem = _v[_ridx];

      HttpProxyServerValidator(_ctx, _info.clone(_ritem)).assertProto();
    }
  }

  void assertField_routers() {
    final _v = _info.proto.routers;

    for (var _ridx = 0; _ridx < _v.length; _ridx++) {
      final _ritem = _v[_ridx];

      RouterItemValidator(_ctx, _info.clone(_ritem)).assertProto();
    }
  }

  void assertOneof(Type oneof) {
    switch (oneof) {
      default:
        throw ArgumentError.value(
            'oneof type($oneof) for ${_info.bi.messageName} not found');
    }
  }

  $3.BuildContext _ctx;

  $6.ValidateInfo<$7.Config> _info;

  $8.ConfigLocalizations _l10n;

  ConfigValidator($3.BuildContext context, $6.ValidateInfo<$7.Config> info)
      : _ctx = context,
        _info = info,
        _l10n = $3.Localizations.of<$8.ConfigLocalizations>(
            context, $8.ConfigLocalizations);
}
